use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;
use std::path::Path;

use crate::cache::Cache;
use crate::model::{CrateInfo, Module};

/// Storage for annotations (module and item descriptions).
///
/// This file is LLM-facing â€” it contains only paths, notes, and status flags.
/// All hashes live in cache.json.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct AnnotationStore {
    #[serde(default)]
    pub modules: BTreeMap<String, AnnotationEntry>,
    #[serde(default)]
    pub items: BTreeMap<String, AnnotationEntry>,
}

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct AnnotationEntry {
    #[serde(default)]
    pub note: String,
    #[serde(default, skip_serializing_if = "is_false")]
    pub stale: bool,
    #[serde(default, skip_serializing_if = "is_false")]
    pub removed: bool,
}

fn is_false(b: &bool) -> bool {
    !b
}

impl AnnotationStore {
    /// Load annotations from the output directory
    pub fn load(output_dir: &Path) -> Result<Self> {
        let path = output_dir.join("annotations.toml");
        let content = std::fs::read_to_string(&path)
            .with_context(|| format!("Cannot read {}", path.display()))?;
        let store: AnnotationStore =
            toml::from_str(&content).context("Failed to parse annotations.toml")?;
        Ok(store)
    }

    /// Save annotations to the output directory
    pub fn save(&self, output_dir: &Path) -> Result<()> {
        let path = output_dir.join("annotations.toml");
        let content = toml::to_string_pretty(self).context("Failed to serialize annotations")?;

        let header = "# Auto-generated by rsmap.\n\
                      # Fill in 'note' fields manually or via LLM.\n\
                      # Entries with stale=true have changed since last annotation.\n\n";

        std::fs::write(&path, format!("{}{}", header, content))
            .with_context(|| format!("Cannot write {}", path.display()))?;
        Ok(())
    }
}

/// Update annotations based on current crate data and cache comparison.
///
/// - New items get empty notes
/// - Changed items (hash differs between old and new cache) get stale=true
/// - Removed items get removed=true
pub fn update_annotations(
    existing: &AnnotationStore,
    crates: &[CrateInfo],
    old_cache: Option<&Cache>,
    new_cache: &Cache,
) -> AnnotationStore {
    let mut updated = existing.clone();

    // Collect current module and item paths
    let mut current_modules: BTreeMap<String, ()> = BTreeMap::new();
    let mut current_items: BTreeMap<String, ()> = BTreeMap::new();

    for crate_info in crates {
        collect_paths(
            &crate_info.root_module,
            &mut current_modules,
            &mut current_items,
        );
    }

    // Update module annotations
    for (path, _) in &current_modules {
        let is_stale = old_cache
            .map(|old| old.module_hash_changed(new_cache, path))
            .unwrap_or(false);

        match updated.modules.get_mut(path) {
            Some(entry) => {
                if is_stale {
                    entry.stale = true;
                }
                entry.removed = false;
            }
            None => {
                updated.modules.insert(
                    path.clone(),
                    AnnotationEntry {
                        note: String::new(),
                        stale: false,
                        removed: false,
                    },
                );
            }
        }
    }

    // Update item annotations
    for (path, _) in &current_items {
        let is_stale = old_cache
            .map(|old| old.item_hash_changed(new_cache, path))
            .unwrap_or(false);

        match updated.items.get_mut(path) {
            Some(entry) => {
                if is_stale {
                    entry.stale = true;
                }
                entry.removed = false;
            }
            None => {
                updated.items.insert(
                    path.clone(),
                    AnnotationEntry {
                        note: String::new(),
                        stale: false,
                        removed: false,
                    },
                );
            }
        }
    }

    // Mark removed items
    for (path, entry) in updated.modules.iter_mut() {
        if !current_modules.contains_key(path) {
            entry.removed = true;
        }
    }
    for (path, entry) in updated.items.iter_mut() {
        if !current_items.contains_key(path) {
            entry.removed = true;
        }
    }

    updated
}

fn collect_paths(
    module: &Module,
    module_paths: &mut BTreeMap<String, ()>,
    item_paths: &mut BTreeMap<String, ()>,
) {
    module_paths.insert(module.path.clone(), ());

    for item in &module.items {
        let item_path = format!("{}::{}", module.path, item.name);
        item_paths.insert(item_path, ());
    }

    for sub in &module.submodules {
        collect_paths(sub, module_paths, item_paths);
    }
}

/// Export unannotated or stale items for LLM annotation
pub fn export_for_annotation(annotations: &AnnotationStore) -> String {
    let mut out = String::new();

    out.push_str("The following items need descriptions. For each, write a brief (1-2 sentence) explanation of what it does and why it exists. Respond in the same TOML format.\n\n---\n\n");

    let mut has_items = false;

    // Export unannotated modules
    for (path, entry) in &annotations.modules {
        if entry.removed {
            continue;
        }
        if entry.note.is_empty() || entry.stale {
            out.push_str(&format!("[modules.\"{}\"]\n", path));
            if entry.stale {
                out.push_str("stale = true\n");
            }
            out.push_str("note = \"\"\n\n");
            has_items = true;
        }
    }

    // Export unannotated items
    for (path, entry) in &annotations.items {
        if entry.removed {
            continue;
        }
        if entry.note.is_empty() || entry.stale {
            out.push_str(&format!("[items.\"{}\"]\n", path));
            if entry.stale {
                out.push_str("stale = true\n");
            }
            out.push_str("note = \"\"\n\n");
            has_items = true;
        }
    }

    if !has_items {
        out = "All items are annotated and up to date.\n".to_string();
    }

    out
}

/// Import annotations from a TOML string (typically LLM-generated)
pub fn import_annotations(store: &mut AnnotationStore, import_content: &str) -> Result<()> {
    let imported: AnnotationStore =
        toml::from_str(import_content).context("Failed to parse import TOML")?;

    // Merge imported modules
    for (path, entry) in imported.modules {
        if let Some(existing) = store.modules.get_mut(&path) {
            if !entry.note.is_empty() {
                existing.note = entry.note;
                existing.stale = false;
            }
        }
    }

    // Merge imported items
    for (path, entry) in imported.items {
        if let Some(existing) = store.items.get_mut(&path) {
            if !entry.note.is_empty() {
                existing.note = entry.note;
                existing.stale = false;
            }
        }
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::model::*;
    use std::path::PathBuf;

    fn sample_crate() -> CrateInfo {
        CrateInfo {
            name: "test".to_string(),
            kind: CrateKind::Lib,
            edition: "2021".to_string(),
            version: "0.1.0".to_string(),
            external_deps: vec![],
            root_module: Module {
                path: "crate".to_string(),
                file_path: PathBuf::from("src/lib.rs"),
                file_hash: "abc123".to_string(),
                doc_comment: None,
                visibility: Visibility::Pub,
                items: vec![Item {
                    name: "init".to_string(),
                    kind: ItemKind::Function,
                    visibility: Visibility::Pub,
                    signature: "pub fn init();".to_string(),
                    doc_comment: None,
                    file_path: PathBuf::from("src/lib.rs"),
                    line_start: 1,
                    line_end: 5,
                    content_hash: "hash1".to_string(),
                }],
                submodules: vec![],
                use_statements: vec![],
                is_inline: false,
            },
        }
    }

    #[test]
    fn test_update_annotations_new() {
        let existing = AnnotationStore::default();
        let crates = vec![sample_crate()];
        let new_cache = Cache::from_crates(&crates);
        let updated = update_annotations(&existing, &crates, None, &new_cache);

        assert!(updated.modules.contains_key("crate"));
        assert!(updated.items.contains_key("crate::init"));
        assert!(!updated.items["crate::init"].stale);
        assert!(updated.items["crate::init"].note.is_empty());
    }

    #[test]
    fn test_update_annotations_stale() {
        let mut existing = AnnotationStore::default();
        existing.items.insert(
            "crate::init".to_string(),
            AnnotationEntry {
                note: "Initializes the system".to_string(),
                stale: false,
                removed: false,
            },
        );

        // Old cache had a different hash
        let mut old_cache = Cache::default();
        old_cache
            .items
            .insert("crate::init".to_string(), "old_hash".to_string());

        let crates = vec![sample_crate()];
        let new_cache = Cache::from_crates(&crates); // hash is "hash1"
        let updated = update_annotations(&existing, &crates, Some(&old_cache), &new_cache);

        assert!(updated.items["crate::init"].stale);
        assert_eq!(
            updated.items["crate::init"].note,
            "Initializes the system"
        );
    }

    #[test]
    fn test_import_annotations() {
        let mut store = AnnotationStore::default();
        store.items.insert(
            "crate::init".to_string(),
            AnnotationEntry {
                note: String::new(),
                stale: false,
                removed: false,
            },
        );

        let import = r#"
[items."crate::init"]
note = "Initializes the application"
"#;

        import_annotations(&mut store, import).unwrap();
        assert_eq!(
            store.items["crate::init"].note,
            "Initializes the application"
        );
    }

    #[test]
    fn test_export_for_annotation() {
        let mut store = AnnotationStore::default();
        store.items.insert(
            "crate::init".to_string(),
            AnnotationEntry {
                note: String::new(),
                stale: false,
                removed: false,
            },
        );
        store.items.insert(
            "crate::run".to_string(),
            AnnotationEntry {
                note: "Already annotated".to_string(),
                stale: false,
                removed: false,
            },
        );

        let export = export_for_annotation(&store);
        assert!(export.contains("crate::init"));
        assert!(!export.contains("crate::run")); // already annotated
        assert!(!export.contains("hash")); // no hashes in export
    }
}
